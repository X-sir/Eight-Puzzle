#author:胡立新
#Date:2017-4-15
#email:2251759674#qq.com


八数码问题

使用广度优先搜索和双向广度优先搜索。

使用IDA*

八数码问题

 

1,逆序数奇偶性剪枝

 这个问题可以用来判定是否有解。

     给定不包括空位置的八数码序列，可以得到一个逆序数。而移动空位置不会改变该序列逆序数奇偶性。

 必要性证明：1.空位进行左/右移动不会改变序列

             2.空位上/下移动即与空位对应位置往前/后第三个数字相互调换.

              相邻两个数字进行调换会使得逆序数加一或者减一

              而上/下移动相当于进行两次在序列中的调换,所以不会改变逆序数奇偶性.

 充分性证明: 据说和循环群有关……不懂

 (十五数码的也可以使用循环群来分析是否有解)

 

2.迭代加深

     迭代加深的搜索方法可以说真是一个非常厉害的方法.

     首先确定一个搜索代价上界d,对求解问题进行代价小于d的深度进行深度优先搜索.如果代价小于d没有解,那么增加深度继续搜.

     而事实上如果d增加,原来小于d的地方会被重复搜索.但是大部分情况,如果多扩展一层结点,其需要搜索到的结点会比原来大得多(据说是10倍以上),那么重复搜索对时间的影响明显就小得多.

     相反,对于类似于需要判重,或者贪心寻找最优策略的算法来说,这里少了用于判重和排序之类问题的时间,同时也减少了非常多用于存储状态空间.或者说,这是用时间来换空间,但事实上某些时候,迭代加深所用的时间甚至还要少.

     编程方面,跟一般的DFS差不多,可以直接在DFS上修改一点点就完成.

 

3.A*启发式搜索

     对于一些贪心策略,实际上可以通过某种特殊的方式,使之更容易接近搜索所得的解.

     定义启发式函数:f(s)=g(s)+h(s) , 作为一个经过状态s到达目标的总估计值.

     函数 g(s)表示到达s已经消耗的实际代价, h(s) 表示从s到达目标的代价估计值.其中,g(s)是已经搜索得到的结果,而h(s)是一个人为定义的函数.

     如果每一次扩展f(s)最小的结点(或者说状态),那么就会得到解(类似BFS或者dijsktra算法).

     至于正确性,只要保证所设计的h(s)<=h*(s), h*(s)表示实际上s到达目标的最小代价.可以证明,只要满足这个条件就一定能成立.事实上,如果h(s)被设计成一个常数,这样的话相当于直接的BFS.

     至于一些性质,可以知道的就是如果状态s1扩展出状态s2,那么f(s1)<=f(s2) (来自黑书),从这一点可以得出一条解的路径是非递减的,或者说是不断逼近解的.

     设计一个好的h(s)可以使得搜索速度大大提高,一个不太实用的解释就是,好的h(s)可以扩展更少的与解无关的结点.

 

4.IDA*

     事实上,迭代加深与A*组合起来效果很不错.迭代上界被设置为启发式函数f(s).

 

5.八数码问题的启发式函数定义曼哈顿距离,效果不错…..(完)